'use strict'

const escape = require('../../escape-typst/src/index')
const visit = require('unist-util-visit')
const path = require('path')
const util = require('./util')
const child_process = require('child_process')
const fs = require('fs')
const unified = require('unified')
const rparse = require('remark-parse')
const math = require('remark-math')
const details = require('remark-details')
const footnotes = require('remark-footnotes')
const request = require('sync-request')
const URL = require('url').URL

// 给 String 添加 format 方法，方便格式化输出
if (!String.prototype.format) {
  String.prototype.format = function () {
    const args = arguments
    return this.replace(/{(\d+)}/g, function (match, number) {
      return typeof args[number] !== 'undefined' ? args[number] : match
    })
  }
}

module.exports = compiler

function compiler(options) {
  const outLinkLable = new Map() // 所有的外部链接，包括直接链接和引用式链接，键-值：链接-链接label
  let hasFootnote = false // 判断之前有没有footnote
  let outLinkBeginCount = 0
  const links = {} // 引用式链接，键-值：标识符-链接地址
  const footnote = {} // 引用式脚注，键-值：序号（1 起始）-脚注内容
  const qrCode = {} // 脚注的二维码
  const indices = {} // 脚注序号，键-值：标识符-脚注序号
  const identifiers = {} // indices 的逆映射
  const footnoteRefs = {} // 脚注被引用的次数，键-值：标识符-引用次数
  const footnoteRefId = {} // 脚注当前被引用第几次，键-值：脚注序号-第几次引用
  let footnoteCount = 0 // 脚注数量
  let inFootnote = false

  parser.prototype.compile = wrapper
  return parser

  function parser(tree, file) {
    this.tree = tree
    this.file = file
  }

  function wrapper() {
    // 处理掉所有标签定义和链接跳转定义
    parseDefinition(this.tree)
    // 解析文章
    let article = `// Generated by remark-typst
#import "imports/tablex.typ": tablex, hlinex
#import "imports/oi-wiki.typ": antiflash-white, info-blue, warning-orange, horizontalrule, blockquote, details, authors, codeblock
`
    article += parse(this.tree)
    // 创建文章尾注
    // if (footnoteCount > 0) {
    //   if (hasFootnote === false) {
    //     article += '\n==== 参考资料与注释'
    //   }
    //   article += '\n\\begin{enumerate}\n'
    //   for (let id = 1; id <= footnoteCount; ++id) {
    //     const fullLabel = options.prefix + identifiers[id]
    //     if (footnoteRefs[identifiers[id]] === 1) {
    //       article += `\\renewcommand{\\labelenumi}{\\hyperref[endnoteref:${fullLabel}-1]{[\\theenumi]}}\n`
    //     } else {
    //       article += '\\renewcommand{\\labelenumi}{[\\theenumi]}\n'
    //     }
    //     article += '\\item\\label{endnote:{0}}'.format(fullLabel) + footnote[id]
    //     if (footnoteRefs[identifiers[id]] >= 2) {
    //       for (let cnt = 1; cnt <= footnoteRefs[identifiers[id]]; ++cnt) {
    //         article += ` \\hyperref[endnoteref:${fullLabel}-${cnt}]{[${id}-${cnt}]}`
    //       }
    //     }
    //     article += '#h(1fr)' // align qrcode to right
    //     // 为尾注增添二维码
    //     const url = getUrlFromFootnote(id)
    //     for (let i = 0; i < url.length; i++) {
    //       url[i] = url[i].replace('\\textasciitilde{}', '~')
    //       // ban cjk urls, due to the fact that they are not supported by latex qrcode
    //       if (url[i].split('').map(c => util.isCjk(c)).filter(c => c).length > 0) {
    //         url[i] = encodeURI(url[i])
    //       }
    //       const urlFormat = `\\quad \\qrcode[height=1cm]{${url[i]}}`
    //       article += urlFormat
    //     }
    //     article += '\n'
    //   }
    //   article += '\\end{enumerate}\n'
    // }
    return article
  }

  // 估测文本长度
  function getEstimatedLength(node) {
    let ans = 0
    if ('value' in node) {
      ans += util.getTextEstimatedLength(node.value)
    }
    if ('children' in node && node.children.length > 0) {
      ans += util.all(node, getEstimatedLength).reduce((prev, val) => prev + val)
    }
    return ans
  }

  function getUrlFromFootnote(id) {
    const regexp = /\\hyref\{.*?\}\{.*?\}/g
    const footnoteTmp = footnote[id]
    const array = [...footnoteTmp.matchAll(regexp)]
    const url = []
    for (let i = 0; i < array.length; i++) {
      const subArray = String(array[i]).split('hyref')
      // 括号匹配
      let leftCnt = 0; let rightCnt = 0
      let position = -1
      for (let j = 0; j < subArray[1].length; j++) {
        if (subArray[1][j] === '{') leftCnt++
        if (subArray[1][j] === '}') rightCnt++
        if (leftCnt !== 0 && leftCnt === rightCnt) {
          position = j
          break
        }
      }
      url[i] = subArray[1].slice(1, position)
    }
    return url
  }

  function parseDefinition(tree) {
    visit(tree, 'footnoteDefinition', function (node) {
      inFootnote = true
      hasFootnote = true
      indices[node.identifier] = ++footnoteCount
      identifiers[footnoteCount] = node.identifier
      footnoteRefId[footnoteCount] = 0
      footnoteRefs[node.identifier] = 0
      footnote[footnoteCount] = util.nonParagraphBegin(util.all(node, parse).join('')).trim()
      const url = getUrlFromFootnote(footnoteCount)
      for (let i = 0; i < url.length; i++) {
        outLinkLable.set(url[i], footnoteCount)
      }
      inFootnote = false
    })

    visit(tree, 'footnoteReference', function (node) {
      ++footnoteRefs[node.identifier]
    })

    visit(tree, 'definition', function (node) {
      if (outLinkBeginCount === 0) {
        outLinkBeginCount = footnoteCount + 1
      }
      links[node.identifier] = escape(node.url)
    })

    visit(tree, 'link', function (node) {
      if (outLinkBeginCount === 0) {
        outLinkBeginCount = footnoteCount + 1
      }
      const location = escape(node.url)
      if (util.isInternalLink(node.url) === false && outLinkLable.has(location) === false) {
        ++footnoteCount
        outLinkLable.set(location, 'OutLink_{0}'.format(footnoteCount))
        indices[outLinkLable.get(location)] = footnoteCount
        identifiers[footnoteCount] = outLinkLable.get(location)
        footnoteRefId[footnoteCount] = 0
        footnoteRefs[outLinkLable.get(location)] = 0
        const children = util.all(node, parse).join('')
        footnote[footnoteCount] = '#link("{0}")[{1}]'.format(location, children)
      }
      footnoteRefs[outLinkLable.get(location)]++
    })
  }

  function parse(node) {
    const makeLink = function (url) {
      const raw = util.all(node, parse).join('')

      const prevForce = options.forceEscape
      options.forceEscape = true
      const children = util.all(node, parse).join('')
      options.forceEscape = prevForce

      if (util.isInternalLink(url)) {
        const location = util.toPrefix(util.joinRelative(url, options))
        return (location !== '' && raw !== '') ? '#link("{0}")[{1}]'.format(location, children) : ''
      } else {
        const location = url.replace(/\\/g, '\\\\')
        if (outLinkLable.has(location) === false || inFootnote) {
          if (location === raw) {
            return '#link("{0}")[{1}]'.format(location, children)
          } else {
            return (location !== '' && raw !== '') ? '#link("{0}")[{1}]'.format(location, children) : ''
          }
        }
        const lable = outLinkLable.get(location)
        const index = indices[lable]
        ++footnoteRefId[index]
        if (location === raw) {
          return '#link("{0}")[{1}]'.format(location, children) + '#footnote[{0}]'.format(footnote[index])
        } else {
          return (location !== '' && raw !== '') ? '#link("{0}")[{1}]'.format(location, children) + '#footnote[{0}]'.format(footnote[index]) : ''
        }
      }
    }

    // 插入图片，若是网络资源则先下载到本地再插入
    const makeImage = function (loc) {
      let uri = util.joinRelative(node.url, options)
      try {
        let ext = ''
        let dest = ''
        if (util.isUrl(loc)) {
          const url = new URL(loc)
          ext = path.extname(url.pathname)
          dest = path.join('images', util.toPrefix(path.join(path.dirname(uri), path.basename(url.pathname, ext))) + ext)
          // download
          if (!fs.existsSync(dest)) {
            const body = request('GET', loc).getBody()
            fs.writeFileSync(dest, body)
          }
          uri = dest
        } else {
          ext = path.extname(loc)
        }
        const is_svg = ext === '.svg'
        dest = path.join('images', util.toPrefix(path.join(path.dirname(uri), path.basename(uri, path.extname(uri)))) + (is_svg ? '.svg' : '.jpg'))
        // convert
        switch (ext) {
          case '.jpg':
          case '.svg': {
            if (!fs.existsSync(dest)) {
              fs.copyFileSync(uri, dest)
            }
            break
          }
          case '.jpeg': {
            if (!fs.existsSync(dest)) {
              fs.copyFileSync(uri, path.basename(dest, 'jpeg') + '.jpg')
            }
            break
          }
          default: {
            if (!fs.existsSync(dest)) {
              // 混合白色背景（原图可能是 PNG 透明图）
              child_process.execFileSync('convert', ['-background', 'white', '-flatten', ext === '.gif' ? uri + '[0]' : uri, dest])
            }
            break
          }
        }
        return '#image("../images/{0}", alt: "{1}")\n'.format(path.basename(dest), node.alt || '')
      } catch (e) {
        console.log('Error occurred when processing image file `{0}`'.format(uri))
        return ''
      }
    }

    // 节点匹配逻辑
    switch (node.type) {
      case 'root': {
        let article = util.trailingLineFeed(util.all(node, parse).join('\n'))
        if (!options.nested) {
          article = '#label("{0}")\n'.format(options.prefix) + article
        }
        return article
      }
      case 'paragraph': {
        const parText = util.all(node, parse).join('')
        if (parText.startsWith('author: ')) {
          return '#authors[{0}]'.format(parText.slice(8))
        }
        if (parText.startsWith('disqus:')) {
          return ''
        }
        return '#par[{0}]\n'.format(parText)
      }
      case 'heading': {
        const depth = Math.min(options.depth + (node.depth - 1), 6)
        return depth <= 3
               ? '#heading(level: {0})[{1}]'.format(depth, util.all(node, parse).join(''))
               : '#heading(level: {0}, numbering: none, outlined: false)[{1}]'.format(depth, util.all(node, parse).join(''))
      }
      case 'text': {
        if (options.forceEscape) {
          return escape(util.forceLinebreak(node.value))
        } else {
          return escape(node.value)
        }
      }
      case 'emphasis': {
        return '#emph[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'strong': {
        return '#strong[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'inlineCode': {
        return '#raw("{0}", block: false)'.format(node.value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/[\n]/g, '\\n'))
      }
      case 'code': {
        return '#codeblock(code: "{0}", lang: "{1}")\n'.format(
          node.value.replace(/\\/g, '\\\\').replace(/"/g, '\\\"').replace(/\n/g, '\\n'),
          (function (lang) {
            if (!lang) { // 默认当作 text
              return 'txt'
            } else if (lang === 'plain') { // plain 替换为 text（纯文本）
              return 'txt'
            } else if (lang === 'markdown') { // markdown 格式的说明符必须是 md，需要替换
              return 'md'
            } else {
              return lang
            }
          })(node.lang)
        )
      }
      case 'delete': {
        return '#strike[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'list': {
        const base = node.ordered
          ? '#enum(start: {0})'.format(node.start)
          : '#list'
        return base + util.all(node, parse).map(s => '[{0}]'.format(s)).join('') + '\n'
      }
      case 'listItem': {
        return util.all(node, parse).join('')
      }
      case 'thematicBreak': { // 水平分割线
        return '#horizontalrule\n' // 在印刷物中使用水平分割线也许不是好的实践
      }
      case 'blockquote': {
        return '#blockquote[{0}]\n'.format(util.all(node, parse).join(''))
      }
      case 'break': {
        return '#parbreak()'
      }
      case 'yaml': {
        return '' // YAML front-matter，这里直接忽略
      }
      case 'html': {
        return '' // HTML 标签（不含标签里的内容，如 <kbd>A</kbd> 会分别产生一个 html('<kbd>'), text('A'), html('</kbd>')，这里直接忽略掉就行
      }
      case 'link': {
        return makeLink(node.url)
      }
      case 'linkReference': {
        if (links[node.identifier]) {
          return makeLink(links[node.identifier])
        }
        return ''
      }
      case 'image': {
        return makeImage(node.url.toLowerCase())
      }
      case 'imageReference': {
        if (links[node.identifier]) {
          return makeImage(links[node.identifier])
        }
        return ''
      }
      case 'table': {
        // 如果表格有多余列（相对表头）则去掉
        node.children.map(function (child) {
          child.children = child.children.slice(0, node.align.length)
        })
        // 估测每列最宽字符串的宽度，为每列分配水平空间
        const width = Array(node.align.length)
        width.fill(0)
        for (let child = 0; child < node.children.length; ++child) {
          for (let id = 0; id < node.children[child].children.length; ++id) {
            width[id] = Math.min(Math.max(width[id], getEstimatedLength(node.children[child].children[id])), 60)
          }
        }
        // 用 longtabu 环境创建可自动适应比例、可自动分页的长表格
        return `#tablex(
columns: ({0}),
align: (col, row) => ({1}).at(col),
auto-lines: false,
hlinex(),
{2}
hlinex(stroke: .5pt),
{3}
hlinex(),
)\n`.format(
          '1fr, '.repeat(node.align.length),
          node.align.map(s => s || 'center').join(','),
          parse(node.children[0]),
          node.children.slice(1).map(parse).join(''))
      }
      case 'tableRow': {
        return util.all(node, parse).join(', ') + ',\n'
      }
      case 'tableCell': {
        return '[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'footnote': {
        return '#footnote[{0}]'.format(util.all(node, parse).join(''))
      }
      case 'footnoteReference': {
        const index = indices[node.identifier]
        ++footnoteRefId[index]
        return '#footnote[{0}]'.format(footnote[index])
      }
      case 'definition': {
        return '' // 已经预处理掉了
      }
      case 'footnoteDefinition': {
        return '' // 已经预处理掉了
      }
      case 'inlineMath': { // 行内公式
        // const nowrap = ['\\LaTeX', '\\TeX'] // 碰到这两个命令时不套 $ 标记
        // const escapeList = ['textit', 'textbf', 'text'] // 内部转义字符串的命令
        // for (const id in nowrap) {
        //   if (node.value.indexOf(nowrap[id]) !== -1) {
        //     return '#text[todo!(iM)]' //util.escapeTextCommand(escapeList, node.value)
        //   }
        // }
        // return '#text[todo!(iM)]'.format(util.escapeTextCommand(escapeList, node.value))
        try {
          const typst = request('POST', 'http://localhost:8080/convert', {
            json: {
              display: false,
              from: 'tex',
              text: node.value,
              to: 'typst',
            }
          }).getBody().toString()
          return '${0}$'.format(typst)
        } catch (e) {
          return '$"MATH_NOT_SUPPORTED: {0}"$'.format(e.message.replace(/\\/g, '\\\\').replace(/"/g, '\\\"'))
        }
      }
      case 'math': { // 行间公式
        // const nowrap = ['{equation}', '{equation*}', '{align}', '{align*}', '{eqnarray}', '{eqnarray*}']
        // const escapeList = ['textit', 'textbf', 'text']
        // for (const id in nowrap) {
        //   if (node.value.indexOf(nowrap[id]) !== -1) {
        //     return '#block[todo!(math)]\n' //util.escapeTextCommand(escapeList, node.value)
        //   }
        // }
        // return '#block[todo!(math)]'.format(util.escapeTextCommand(escapeList, node.value))
        try {
          const typst = request('POST', 'http://localhost:8080/convert', {
            json: {
              display: true,
              from: 'tex',
              text: node.value,
              to: 'typst',
            }
          }).getBody().toString()
          return '$ {0} $'.format(typst)
        } catch (e) {
          return '$ "MATH_NOT_SUPPORTED: {0}" $'.format(e.message.replace(/\\/g, '\\\\').replace(/"/g, '\\\"'))
        }
      }
      case 'details': { // Pymdown details 语法块
        const type = (node.value || '').toLowerCase().trim() === 'warning' ? 'Warning' : 'Note'
        const prevNested = options.nested
        options.nested = true
        let title = util.nonParagraphBegin(parse(unified()
          .use(rparse)
          .use(math)
          .use(details)
          .use(footnotes)
          .parse(node.title ? node.title : type)
        ))
        options.nested = prevNested
        const color = type === 'Warning' ? 'warning-orange' : 'info-blue'
        return '#details(color: {0})[{1}][{2}]\n'.format(color, title, util.all(node, parse).join(''))
      }
      default: {
        console.error('Unsupported node type: {0}'.format(node.type))
        console.error(JSON.stringify(node, null, '\t'))
        return ''
      }
    }
  }
}
