'use strict'

import { extname, join, dirname, basename } from 'path'
import { execFileSync, spawnSync } from 'child_process'
import { existsSync, writeFileSync, copyFileSync } from 'fs'
import { URL } from 'url'

import { visit } from 'unist-util-visit'
import request from 'sync-request'

// Utilities
import {
  all, isInternalLink, toPrefix, joinRelative, isUrl, trailingLineFeed,
  forceLinebreak, escapeAsString, checkCodeLang, capitalize, unquote
} from './util.js'
// Escape reserved symbols
import escape from '../escape-typst/src/index.js'
// MathJax SVG export
import { renderSvg } from '../remark-mathjax/svg.js'

// 给 String 添加 format 方法，方便格式化输出
if (!String.prototype.format) {
  String.prototype.format = function () {
    const args = arguments
    return this.replace(/{(\d+)}/g, (match, number) => {
      return typeof args[number] !== 'undefined' ? args[number] : match
    })
  }
}

const WARNING = '\x1b[1;33m[WARNING]\x1b[0m '
const ERROR = '\x1b[1;31m[ERROR]\x1b[0m '
const ZWSP = '\u200b'

// Valid types for Pymdown details
const DETAILS_TYPES = [
  'note', 'abstract', 'info', 'tip', 'success', 'question',
  'warning', 'failure', 'danger', 'bug', 'example', 'quote',
]
const ARTICLE_HEADER = `// Generated by remark-typst
#import "../oi-wiki.typ": *
`

export default toTypst

function toTypst(tree, options) {
  // Key: string - Value: node
  const mapFootnoteDefinitions = new Map()
  // Key: string - Value: node
  const mapDefinitions = new Map()
  // Item: { location: string, plainText: string }
  const arrayLinks = new Array()
  // This array is served as a stack.
  // That its last item is (not) `true` suggests
  // that indentation should (not) be performed.
  const indentPar = new Array(true)

  // Index of current outer link
  let linkIndex = 0
  // Used to indicate whether the section named "References"
  // is already present in original markdown document
  let hasFootnotes = false
  // Whether to parse images to plain texts (title, alt, or simply url)
  // for use in references
  let parsingPlain = false
  // Whether we are parsing table headers right now
  let inTableHeader = false
  // Whether the current details block should be unwrapped
  let unwrap = false
  // Whether the current text node should be escaped as a string
  let isEscapingAsString = false
  // Whether we are in details block right now
  // let inDetails = false

  // Main procedure
  // 处理掉所有标签定义和链接跳转定义
  parseDefinition(tree)
  // 解析文章
  let article = ARTICLE_HEADER + parse(tree)
  // 创建文章尾注，对外链添加二维码
  if (linkIndex > 0) {
    if (hasFootnotes === false) {
      article += '#heading(level: {0}, numbering: none, outlined: false)[外部参考资料]\n'.format(
        options.depth + 1)
    }

    article += '#links-grid('
    for (const [i, link] of arrayLinks.entries()) {
      article += 'links-cell[#text(fill: cmyk(0%, 100%, 100%, 0%))[\\[{0}\\]] #link("{1}")[{2}]], qrcode("{1}"), \n'.format(
        i + 1,
        link.location.replace(/\\/g, '\\\\'),
        link.plainText)
    }
    article += ')\n'
  }
  return article

  // Functions
  function parseDefinition(tree) {
    visit(tree, 'footnoteDefinition', node => {
      mapFootnoteDefinitions.set(node.identifier, node)
    })

    visit(tree, 'definition', node => {
      mapDefinitions.set(node.identifier, node)
    })
  }

  function parse(node) {
    const makeLink = function (url) {
      if (isInternalLink(url)) {
        const location = toPrefix(joinRelative(url, options))

        return (location !== '') ? `@${location}` : ''
      } else {
        const location = url.replace(/\\/g, '\\\\')
        ++linkIndex

        const children = all(node, parse).join('')
        parsingPlain = true
        const plainText = all(node, parse).join('')
        parsingPlain = false
        arrayLinks.push({ location: location, plainText: plainText })

        return '#link("{0}")[{1}]#super(text(fill: cmyk(0%, 100%, 100%, 0%))[{2}\\[{3}\\]])'.format(
          location,
          children,
          ZWSP,
          linkIndex)
      }
    }

    // 插入图片，若是网络资源则先下载到本地再插入
    const makeImage = function (loc) {
      // NOTE: hugh, why should we copy all files into here,
      // while we can actually visit them in-place?
      let uri = joinRelative(node.url, options)
      try {
        let ext = ''
        let dest = ''
        if (isUrl(loc)) {
          const url = new URL(loc)
          ext = extname(url.pathname)
          dest = join('images', toPrefix(join(dirname(uri), basename(url.pathname, ext))) + ext)
          // download
          if (!existsSync(dest)) {
            const body = request('GET', loc).getBody()
            writeFileSync(dest, body)
          }
          uri = dest
        } else {
          ext = extname(loc)
        }
        const is_svg = ext === '.svg'
        dest = join('images', toPrefix(join(dirname(uri), basename(uri, extname(uri)))) + (is_svg ? '.svg' : '.jpg'))
        // convert
        switch (ext) {
          case '.jpg':
          case '.svg': {
            if (!existsSync(dest)) {
              copyFileSync(uri, dest)
            }
            break
          }
          case '.jpeg': {
            if (!existsSync(dest)) {
              copyFileSync(uri, basename(dest, 'jpeg') + '.jpg')
            }
            break
          }
          default: {
            if (!existsSync(dest)) {
              // 混合白色背景（原图可能是 PNG 透明图）
              execFileSync(
                'convert',
                ['-background', 'white', '-flatten', ext === '.gif' ? uri + '[0]' : uri, dest])
            }
            break
          }
        }
        return '#img-auto("./images/{0}", alt: "{1}")\n'.format(
          basename(dest),
          node.alt || '',
        )
      } catch (e) {
        console.error(ERROR + 'Error occurred when processing image file "{0}"'.format(uri))
        return ''
      }
    }

    // 节点匹配逻辑
    switch (node.type) {
      case 'root': {
        const article = trailingLineFeed(all(node, parse).join('\n'))
        return article
      }
      case 'paragraph': {
        const parText = all(node, parse).join('')

        if (parText.startsWith('author: ')) {
          return '#authors[{0}]\n'.format(parText.slice(8))
        }
        if (parText.startsWith('disqus:')) {
          return ''
        }

        if (indentPar.at(-1)) {
          return '#h(2em){0}\n\n'.format(parText)
        }
        return '{0}\n\n'.format(parText)
      }
      case 'heading': {
        const depth = Math.min(options.depth + (node.depth - 1), 6)
        return '#heading(level: {0}, numbering: none, outlined: false)[{1}]'.format(
          depth,
          all(node, parse).join(''),
          options.nested ? '' : options.prefix)
      }
      case 'text': {
        // NOTE: remove spaces between text objects?
        // since this is not a common practice in east asian typesetting.
        let text = node.value

        if (options.forceLinebreak) {
          text = forceLinebreak(text)
        }

        if (isEscapingAsString) {
          text = escapeAsString(text)
        } else {
          text = escape(text)
        }

        return text
      }
      case 'emphasis': {
        return '#emph[{0}]'.format(all(node, parse).join(''))
      }
      case 'strong': {
        return '#strong[{0}]'.format(all(node, parse).join(''))
      }
      case 'inlineCode': {
        return '#raw("{0}", block: false)'.format(escapeAsString(node.value))
      }
      case 'code': {
        const ret = '#sourcecode[`````{1}\n{0}\n`````]'.format(
          node.value,
          checkCodeLang(node.lang) || 'text')
        unwrap = false

        return ret
      }
      case 'delete': {
        return '#strike[{0}]'.format(all(node, parse).join(''))
      }
      case 'list': {
        indentPar.push(false)

        const func = node.ordered
          ? '#enum(start: {0})'.format(node.start)
          : '#list'
        const ret = func + all(node, parse).map(s => `[${s}]`).join('') + '\n'

        indentPar.pop()
        return ret
      }
      case 'listItem': {
        return all(node, parse).join('')
      }
      case 'thematicBreak': { // 水平分割线
        return '#horizontalrule\n' // 在印刷物中使用水平分割线也许不是好的实践
      }
      case 'blockquote': {
        return '#blockquote[{0}]\n'.format(all(node, parse).join(''))
      }
      case 'break': {
        return '\n\n'
      }
      case 'yaml': {
        return '' // YAML front-matter，这里直接忽略
      }
      case 'html': { // HTML 标签（不含标签里的内容）
        if (node.value === '<kbd>') {
          isEscapingAsString = true
          return '#kbd("'
        } else if (node.value === '</kbd>') {
          isEscapingAsString = false
          return '")'
        }
        return ''
      }
      case 'link': {
        return makeLink(node.url)
      }
      case 'linkReference': {
        const defn = mapDefinitions.get(node.identifier)
        if (defn) {
          return makeLink(defn.url)
        }
        return ''
      }
      case 'image': {
        if (parsingPlain) {
          return node.title || node.alt || node.url
        }
        return makeImage(node.url.toLowerCase())
      }
      case 'imageReference': {
        const defn = mapDefinitions.get(node.identifier)
        if (defn) {
          if (parsingPlain) {
            return defn.title || defn.alt || defn.url
          }
          return makeImage(defn.url)
        }
        return ''
      }
      case 'table': {
        // 如果表格有多余列（相对表头）则去掉
        node.children.map(child => {
          child.children = child.children.slice(0, node.align.length)
        })

        inTableHeader = true
        const header = parse(node.children[0])
        inTableHeader = false

        return '#tablex-custom(columns: {0}, aligns: ({1}), {2}{3})'.format(
          node.align.length,
          node.align.map(s => s || 'left').join(', '),
          header,
          node.children.slice(1).map(parse).join(''))
      }
      case 'tableRow': {
        return all(node, parse).join(', ') + ', \n'
      }
      case 'tableCell': {
        if (inTableHeader) {
          return 'strong[{0}]'.format(all(node, parse).join(''))
        }
        return '[{0}]'.format(all(node, parse).join(''))
      }
      case 'footnote': {
        hasFootnotes = true
        indentPar.push(false)

        const ret = '#footnote[{0}]'.format(all(node, parse).join(''))

        indentPar.pop()
        return ret
      }
      case 'footnoteReference': {
        hasFootnotes = true
        indentPar.push(false)

        const ret = '#footnote[{0}]'.format(
          all(mapFootnoteDefinitions.get(node.identifier), parse).join(''))

        indentPar.pop()
        return ret
      }
      case 'definition': {
        return '' // 已经预处理掉了
      }
      case 'footnoteDefinition': {
        return '' // 已经预处理掉了
      }
      case 'inlineMath': { // 行内公式
        return `#mi(\`${node.value}\`)`
      }
      case 'math': { // 行间公式
        const tags = node.value.match(/\\tag{(?<tagNumber>[0-9]+)}/)
        return tags
          ? `#mitex(numbering: ignored => "(${tags.groups.tagNumber})", \`${node.value}\`)`
          : `#mitex(\`${node.value}\`)`
      }
      case 'detailsContainer': { // Pymdown details 语法块
        // inDetails = true
        indentPar.push(true)

        const type = node.attributes.class
        const summary = parse(node.children[0])
        const isTrivial = DETAILS_TYPES.includes(summary)

        unwrap = node.children && (node.children.length === 2) && (node.children[1].type === 'code')
        node.children = node.children.slice(1)

        let ret
        if (type) {
          ret = '#details(type: "{0}", unwrap: {1})[{2}][{3}]'.format(
            type,
            unwrap,
            unquote(summary),
            all(node, parse).join('')
          )
        } else if (isTrivial) {
          ret = '#details(type: "{0}", unwrap: {1})[{2}][{3}]'.format(
            summary,
            unwrap,
            capitalize(summary),
            all(node, parse).join('')
          )
        } else {
          ret = '#details(type: "note", unwrap: {0})[{1}][{2}]'.format(
            unwrap,
            unquote(summary),
            all(node, parse).join('')
          )
        }

        indentPar.pop()
        // inDetails = false
        return ret
      }
      case 'detailsContainerSummary': {
        return all(node, parse).join('')
      }
      case 'tabbedContainer': {
        indentPar.push(true)
        unwrap = node.children && (node.children.length === 2) && (node.children[1].type === 'code')

        const title = unquote(parse(node.children[0]))
        node.children = node.children.slice(1)

        const ret = '#tabbed(unwrap: {0})[{1}][{2}]'.format(
          unwrap,
          title,
          all(node, parse).join(''))

        indentPar.pop()
        return ret
      }
      case 'tabbedContainerTitle': {
        return all(node, parse).join('')
      }
      default: {
        console.error(ERROR + 'Unsupported node type: {0}'.format(node.type))
        console.error(JSON.stringify(node, null, '\t'))
        return ''
      }
    }
  }
}
